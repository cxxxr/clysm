# Feature Specification: Interpreter Bootstrap Strategy

**Feature Branch**: `044-interpreter-bootstrap`
**Created**: 2025-12-28
**Status**: Draft
**Input**: User description: "Feature 044: Interpreter Bootstrap Strategy - Extend Tier 1 interpreter to support all CL features needed for compiler self-hosting. Goal: Complete Phase 13 (fixed-point verification, SBCL-free development)."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Run Compiler Source on Interpreter (Priority: P1)

A developer wants to execute the Clysm compiler source code using the extended Tier 1 interpreter instead of SBCL. The interpreter evaluates all 45 compiler modules and produces a working Stage 0 Wasm binary.

**Why this priority**: This is the foundational capability. Without the ability to interpret the compiler source, no subsequent self-hosting stages are possible. This enables SBCL-free development.

**Independent Test**: Can be fully tested by loading all compiler modules into the interpreter and calling `compile-to-wasm` on test expressions, verifying the generated Wasm is valid.

**Acceptance Scenarios**:

1. **Given** the extended interpreter is loaded, **When** all 45 compiler modules are evaluated via `(interpret-file "path/to/module.lisp")`, **Then** no unhandled errors occur and all module definitions are available.
2. **Given** all compiler modules are loaded in the interpreter, **When** `(compile-to-wasm '(+ 1 2))` is called, **Then** valid Wasm bytecode is returned that executes correctly on wasmtime.
3. **Given** the interpreter has special form `defun` support, **When** `(defun foo (x) (* x 2))` is interpreted, **Then** calling `(foo 21)` returns 42.

---

### User Story 2 - Generate Stage 0 Binary via Interpreter (Priority: P2)

A developer wants to generate the Stage 0 Wasm binary by running the entire bootstrap process through the interpreter. The interpreter reads all source files, compiles each form, and produces a complete Stage 0 binary.

**Why this priority**: Stage 0 generation is the first concrete output of self-hosting. It proves the interpreter can fully substitute for SBCL in the bootstrap chain.

**Independent Test**: Can be tested by running `(generate-stage0-via-interpreter)` and validating the output binary with `wasm-tools validate`.

**Acceptance Scenarios**:

1. **Given** the interpreter has all required CL features, **When** `(generate-stage0-via-interpreter)` is invoked, **Then** `dist/clysm-stage0-interp.wasm` is created.
2. **Given** the interpreter-generated Stage 0 binary exists, **When** `wasm-tools validate dist/clysm-stage0-interp.wasm` is run, **Then** validation passes without errors.
3. **Given** the interpreter-generated Stage 0 binary, **When** it is loaded into wasmtime and `(+ 1 2)` is compiled, **Then** the result matches SBCL-generated Stage 0 output.

---

### User Story 3 - Achieve Fixed-Point Verification (Priority: P3)

A developer wants to verify that the compiler is truly self-hosting by achieving fixed-point: Stage 1 (generated by Stage 0) equals Stage 2 (generated by Stage 1) byte-for-byte.

**Why this priority**: Fixed-point verification is the ultimate proof of self-hosting. It demonstrates that the compiler can reproduce itself without any external dependencies.

**Independent Test**: Can be tested by running `./scripts/verify-fixpoint.sh` and checking exit code 0 (ACHIEVED).

**Acceptance Scenarios**:

1. **Given** Stage 0 is generated via interpreter, **When** Stage 0 compiles Clysm source to produce Stage 1, and Stage 1 compiles Clysm source to produce Stage 2, **Then** `diff -q dist/clysm-stage1.wasm dist/clysm-stage2.wasm` reports no differences.
2. **Given** the fixed-point verification script, **When** `./scripts/verify-fixpoint.sh` is executed, **Then** exit code is 0 (ACHIEVED) and JSON output shows `identical: true`.
3. **Given** multiple runs of Stage 2 generation, **When** the binaries are compared, **Then** they are deterministically identical (reproducible builds).

---

### User Story 4 - Support All Compiler-Required Special Forms (Priority: P1)

A developer expects the interpreter to handle all Common Lisp special forms and macros that the Clysm compiler source uses, including `defun`, `defmacro`, `defstruct`, `loop`, `typecase`, `handler-case`, `cond`, `case`, `multiple-value-bind`, etc.

**Why this priority**: Equal to P1 because US1 depends on this. The compiler source cannot be interpreted without these features.

**Independent Test**: Can be tested by interpreting each special form in isolation and verifying correct behavior.

**Acceptance Scenarios**:

1. **Given** `defmacro` support, **When** `(defmacro when (test &body body) \`(if ,test (progn ,@body)))` is interpreted, **Then** `(when t 1 2 3)` returns 3.
2. **Given** `defstruct` support, **When** `(defstruct point x y)` is interpreted, **Then** `(make-point :x 1 :y 2)` creates a point and `(point-x pt)` returns 1.
3. **Given** `loop` macro support, **When** `(loop for i from 1 to 5 collect (* i i))` is interpreted, **Then** the result is `(1 4 9 16 25)`.
4. **Given** `handler-case` support, **When** `(handler-case (error "test") (error (c) "caught"))` is interpreted, **Then** the result is "caught".
5. **Given** `typecase` support, **When** `(typecase 42 (string "str") (integer "int"))` is interpreted, **Then** the result is "int".

---

### User Story 5 - SBCL-Free Development Workflow (Priority: P4)

A developer wants to develop and test Clysm entirely without SBCL, using only the interpreter and wasmtime. Changes to compiler source are validated by re-running through the interpreter and checking Stage 1/2 output.

**Why this priority**: This is the end-goal workflow but depends on all previous stories being complete.

**Independent Test**: Can be tested by modifying a compiler source file, regenerating Stage 0/1/2 via interpreter, and verifying the change is reflected.

**Acceptance Scenarios**:

1. **Given** a complete interpreter bootstrap setup, **When** `./scripts/bootstrap-without-sbcl.sh` is run, **Then** a full Stage 0-1-2 cycle completes using only wasmtime.
2. **Given** a modification to a compiler source file, **When** Stage 0 is regenerated via interpreter, **Then** the change is reflected in Stage 0 behavior.
3. **Given** the SBCL-free workflow, **When** all unit tests are run, **Then** test pass rate matches SBCL-based workflow.

---

### Edge Cases

- What happens when the interpreter encounters an unsupported special form? (Signal a clear `unsupported-feature` error with the form name)
- How does the interpreter handle circular references in `labels`? (Already supported via forward reference binding)
- What happens if `defstruct` is called with inheritance? (Support single inheritance matching Clysm's limited struct support)
- How does the interpreter handle `&optional` and `&key` with default values? (Evaluate default forms in the appropriate environment)
- What if macro expansion exceeds depth limit? (Signal `macro-expansion-depth-exceeded` after 1000 iterations)
- How are `declare` forms in function bodies handled? (Ignore declarations as they are type hints only)

## Requirements *(mandatory)*

### Functional Requirements

#### Interpreter Core Extensions

- **FR-001**: Interpreter MUST support `defun` with full lambda-list (&optional, &rest, &key, &allow-other-keys, &aux, supplied-p parameters)
- **FR-002**: Interpreter MUST support `defmacro` with full macro lambda-list (&whole, &environment, &body)
- **FR-003**: Interpreter MUST support `defvar`, `defparameter`, and `defconstant` for global variable definitions
- **FR-004**: Interpreter MUST support `defstruct` with slot options (:initarg, :accessor, :initform, :type)
- **FR-005**: Interpreter MUST support `cond` special form with arbitrary number of clauses
- **FR-006**: Interpreter MUST support `case` and `ecase` forms with proper key matching
- **FR-007**: Interpreter MUST support `typecase`, `etypecase`, and `ctypecase` macros
- **FR-008**: Interpreter MUST support `loop` macro with `for`, `collect`, `do`, `when`, `unless`, `repeat`, `while`, `until` clauses
- **FR-009**: Interpreter MUST support `handler-case` and `handler-bind` for condition handling
- **FR-010**: Interpreter MUST support `restart-case`, `restart-bind`, and `invoke-restart` for restart system
- **FR-011**: Interpreter MUST support `multiple-value-bind`, `multiple-value-list`, `values`, `values-list`
- **FR-012**: Interpreter MUST support `unwind-protect` for cleanup forms
- **FR-013**: Interpreter MUST support `the` and `locally` with `declare` forms (declarations are ignored)
- **FR-014**: Interpreter MUST support `eval-when` with :compile-toplevel, :load-toplevel, :execute
- **FR-015**: Interpreter MUST support `in-package` for package switching during file interpretation

#### Macro System

- **FR-016**: Interpreter MUST support macro expansion via `macroexpand-1` and `macroexpand`
- **FR-017**: Interpreter MUST maintain a macro registry separate from function registry
- **FR-018**: Interpreter MUST support nested macro expansion to full depth
- **FR-019**: Interpreter MUST support `macro-function` and `(setf macro-function)` API

#### Built-in Functions

- **FR-020**: Interpreter MUST provide 100+ built-in CL functions including: `make-hash-table`, `gethash`, `puthash`, `remhash`, `maphash`, `format`, `error`, `warn`, `signal`, `assert`, `check-type`, `typep`, `subtypep`, `type-of`, `coerce`
- **FR-021**: Interpreter MUST provide sequence functions: `map`, `mapcar`, `mapcan`, `mapc`, `reduce`, `find`, `find-if`, `position`, `remove`, `remove-if`, `substitute`, `substitute-if`, `count`, `count-if`, `member`, `assoc`, `rassoc`
- **FR-022**: Interpreter MUST provide string functions: `string=`, `string<`, `string>`, `string-upcase`, `string-downcase`, `concatenate`, `subseq`, `char`, `length`, `format`
- **FR-023**: Interpreter MUST provide numeric functions: `floor`, `ceiling`, `truncate`, `round`, `mod`, `rem`, `abs`, `min`, `max`, `gcd`, `lcm`, `expt`, `sqrt`, `log`, `sin`, `cos`

#### File Operations

- **FR-024**: Interpreter MUST support `interpret-file` to load and evaluate a source file
- **FR-025**: Interpreter MUST support `with-open-file` for file I/O during interpretation
- **FR-026**: Interpreter MUST handle `in-package` forms to switch the current package during file loading
- **FR-027**: Interpreter MUST ignore `declare` forms at top level and in function bodies

#### Stage 0 Generation

- **FR-028**: System MUST provide `generate-stage0-via-interpreter` function that produces a valid Wasm binary
- **FR-029**: Stage 0 generation MUST process all 45 compiler modules in dependency order
- **FR-030**: Stage 0 generation MUST skip non-compilable forms (in-package, declare, etc.) matching existing bootstrap behavior
- **FR-031**: Stage 0 binary MUST be validated by `wasm-tools validate` without errors

#### Fixed-Point Infrastructure

- **FR-032**: System MUST provide scripts to run Stage 0 - Stage 1 - Stage 2 generation chain
- **FR-033**: System MUST compare Stage 1 and Stage 2 binaries byte-for-byte
- **FR-034**: System MUST report fixed-point status with standard exit codes (0=achieved, 1=not achieved, 2=error)
- **FR-035**: System MUST generate JSON reports for CI integration

### Key Entities

- **Interpreter Environment**: The binding environment for variables, functions, and macros with parent chain lookup
- **Macro Registry**: Hash table mapping macro names to their expander functions, separate from the function namespace
- **Stage Binary**: A valid Wasm binary output from compilation (Stage 0, Stage 1, or Stage 2)
- **Compilation Result**: Struct containing Wasm bytes, statistics, and error information from a bootstrap run

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Interpreter successfully evaluates all 45 compiler source modules without errors
- **SC-002**: Interpreter-generated Stage 0 produces identical compilation output to SBCL-generated Stage 0 for 100% of test expressions
- **SC-003**: Fixed-point verification achieves status ACHIEVED (Stage 1 == Stage 2 byte-for-byte)
- **SC-004**: All 400+ unit tests pass when run against interpreter-bootstrapped compiler
- **SC-005**: Stage 0 generation via interpreter completes in under 5 minutes on reference hardware
- **SC-006**: No manual intervention required for the full bootstrap cycle (fully automated)
- **SC-007**: CI pipeline can run the full Stage 0 - 1 - 2 verification without SBCL installed

## Assumptions

1. The existing Tier 1 interpreter architecture (environment chain, closure representation) is suitable for extension
2. SBCL's macro expansion can be replaced by interpreter-based expansion for bootstrap purposes
3. The 45 compiler modules do not use CL features beyond what is practical to implement in the interpreter
4. wasmtime provides sufficient FFI capabilities for Stage 0/1/2 execution
5. The blessed subset of CL features (documented in Feature 036) is sufficient for self-hosting
6. File I/O for source reading can be delegated to the host environment during interpretation

## Non-Goals

1. Achieving performance parity with SBCL for general Lisp evaluation
2. Supporting the full ANSI CL specification beyond what the compiler requires
3. Implementing a full reader (use SBCL's reader for initial source parsing)
4. Supporting multiple inheritance in defstruct
5. Implementing full CLOS dispatch (only single-dispatch as used by compiler)

## Dependencies

- Feature 017: Eval/JIT Compile System (provides existing Tier 1 interpreter base)
- Feature 036: Compiler Subset Validation (documents the blessed CL subset)
- Feature 037-040: Stage 0/1/2 infrastructure (provides generation and verification scripts)
- Feature 042: Advanced Defmacro (provides &whole, &environment support patterns)
