# Research: Compiler Internal Function Consolidation

**Date**: 2026-01-01
**Branch**: `001-internal-function-consolidation`

## Executive Summary

Research confirms that 2 of 7 internal functions require new exports (COMPILE-UNARY-MATH-FFI, COMPILE-CXR-CHAIN), while 5 are already exported. Dead code analysis identified 27 compile-* functions in func-section.lisp that correspond to runtime library implementations, representing approximately 6,500 removable lines.

## Internal Function Export Research

### Decision: Mixed Export Strategy

**Rationale**: Most functions are already exported through the clysm package export chain. Only 2 functions (COMPILE-UNARY-MATH-FFI, COMPILE-CXR-CHAIN) are internal to func-section.lisp and require explicit export additions.

**Alternatives considered**:
1. Export all 7 functions individually - Rejected: 5 already exported, would duplicate
2. Create new internal-functions package - Rejected: Over-engineering for 2 exports
3. Add to existing export list in func-section package - Selected: Minimal change

### Function-by-Function Analysis

#### 1. ENV-ADD-LOCAL
- **Status**: Already exported
- **Location**: func-section.lisp:196
- **Export chain**: clysm/compiler/codegen/func-section → clysm
- **Action**: Verify visibility during Stage 1 compilation

#### 2. COMPILE-TO-INSTRUCTIONS
- **Status**: Already exported
- **Location**: func-section.lisp:351
- **Export chain**: clysm/compiler/codegen/func-section → clysm
- **Action**: Verify visibility during Stage 1 compilation

#### 3. MAKE-WASM-STRUCT-TYPE
- **Status**: Already exported (as MAKE-WASM-STRUCT-TYPE*)
- **Location**: type-construction.lisp:101
- **Note**: The Wasm-compilable variant uses * suffix convention
- **Action**: Verify naming convention used in Stage 1 forms

#### 4. COMPILE-UNARY-MATH-FFI
- **Status**: NOT exported - REQUIRES EXPORT
- **Location**: func-section.lisp:6758
- **Package**: #:clysm/compiler/codegen/func-section
- **Action**: Add to package export list and re-export from clysm

#### 5. AST-LITERAL-VALUE
- **Status**: Already exported
- **Location**: ast.lisp:28 (defstruct accessor)
- **Export chain**: clysm/compiler/ast → clysm
- **Note**: Generated by (defstruct (ast-literal (:conc-name ast-literal-)) ...)
- **Action**: Verify visibility during Stage 1 compilation

#### 6. COMPILE-CXR-CHAIN
- **Status**: NOT exported - REQUIRES EXPORT
- **Location**: func-section.lisp:4059
- **Package**: #:clysm/compiler/codegen/func-section
- **Action**: Add to package export list and re-export from clysm

#### 7. LOOP-KEYWORD-EQ
- **Status**: Already exported
- **Location**: macros.lisp:818
- **Export chain**: clysm/lib/macros → clysm
- **Action**: Verify visibility during Stage 1 compilation

## Dead Code Removal Research

### Decision: Safe Removal via compile-* Function Pattern

**Rationale**: Functions prefixed with `compile-` in func-section.lisp generate inline Wasm code for specific operations. When a runtime library version exists, the compile-* version becomes dead code because the compiler dispatches to runtime calls instead.

**Alternatives considered**:
1. Keep compile-* as fallback - Rejected: Runtime library is the canonical implementation
2. Convert to runtime calls conditionally - Rejected: Already done; dead code remains
3. Remove dead code entirely - Selected: Cleanest approach, tests verify correctness

### Dead Code Identification Method

```lisp
;; Pattern: If (gethash "function-name" *runtime-function-table*) exists,
;; then compile-function-name in func-section.lisp is dead code
```

### Confirmed Dead Code Functions

Based on runtime library contents:

#### From io-runtime.lisp (282 lines)
| Runtime Function | Dead Code in func-section.lisp | Est. Lines |
|-----------------|--------------------------------|------------|
| [princ](resources/HyperSpec/Body/f_wr_pr.htm) | compile-princ | ~150 |
| [prin1](resources/HyperSpec/Body/f_wr_pr.htm) | compile-prin1 | ~150 |
| [print](resources/HyperSpec/Body/f_wr_pr.htm) | compile-print | ~100 |
| [write](resources/HyperSpec/Body/f_wr_pr.htm) | compile-write | ~200 |
| [format](resources/HyperSpec/Body/f_format.htm) | compile-format | ~500 |
| [terpri](resources/HyperSpec/Body/f_terpri.htm) | compile-terpri | ~50 |
| **Subtotal** | | ~1,150 |

#### From list-runtime.lisp (320 lines)
| Runtime Function | Dead Code in func-section.lisp | Est. Lines |
|-----------------|--------------------------------|------------|
| [member](resources/HyperSpec/Body/f_mem_m.htm) | compile-member | ~200 |
| [member-if](resources/HyperSpec/Body/f_mem_m.htm) | compile-member-if | ~150 |
| [member-if-not](resources/HyperSpec/Body/f_mem_m.htm) | compile-member-if-not | ~150 |
| [assoc](resources/HyperSpec/Body/f_assocc.htm) | compile-assoc | ~200 |
| [assoc-if](resources/HyperSpec/Body/f_assocc.htm) | compile-assoc-if | ~150 |
| [assoc-if-not](resources/HyperSpec/Body/f_assocc.htm) | compile-assoc-if-not | ~150 |
| [rassoc](resources/HyperSpec/Body/f_rassoc.htm) | compile-rassoc | ~200 |
| [rassoc-if](resources/HyperSpec/Body/f_rassoc.htm) | compile-rassoc-if | ~150 |
| [rassoc-if-not](resources/HyperSpec/Body/f_rassoc.htm) | compile-rassoc-if-not | ~150 |
| [find](resources/HyperSpec/Body/f_find_.htm) | compile-find | ~200 |
| [find-if](resources/HyperSpec/Body/f_find_.htm) | compile-find-if | ~150 |
| [find-if-not](resources/HyperSpec/Body/f_find_.htm) | compile-find-if-not | ~150 |
| [position](resources/HyperSpec/Body/f_pos_p.htm) | compile-position | ~200 |
| [position-if](resources/HyperSpec/Body/f_pos_p.htm) | compile-position-if | ~150 |
| [position-if-not](resources/HyperSpec/Body/f_pos_p.htm) | compile-position-if-not | ~150 |
| **Subtotal** | | ~2,550 |

#### From sequence-runtime.lisp (454 lines)
| Runtime Function | Dead Code in func-section.lisp | Est. Lines |
|-----------------|--------------------------------|------------|
| [remove](resources/HyperSpec/Body/f_rm_rm.htm) | compile-remove | ~250 |
| [remove-if](resources/HyperSpec/Body/f_rm_rm.htm) | compile-remove-if | ~200 |
| [remove-if-not](resources/HyperSpec/Body/f_rm_rm.htm) | compile-remove-if-not | ~200 |
| [delete](resources/HyperSpec/Body/f_rm_rm.htm) | compile-delete | ~250 |
| [delete-if](resources/HyperSpec/Body/f_rm_rm.htm) | compile-delete-if | ~200 |
| [delete-if-not](resources/HyperSpec/Body/f_rm_rm.htm) | compile-delete-if-not | ~200 |
| [count](resources/HyperSpec/Body/f_countc.htm) | compile-count | ~200 |
| [count-if](resources/HyperSpec/Body/f_countc.htm) | compile-count-if | ~150 |
| [count-if-not](resources/HyperSpec/Body/f_countc.htm) | compile-count-if-not | ~150 |
| [substitute](resources/HyperSpec/Body/f_sbs_s.htm) | compile-substitute | ~250 |
| [substitute-if](resources/HyperSpec/Body/f_sbs_s.htm) | compile-substitute-if | ~200 |
| [substitute-if-not](resources/HyperSpec/Body/f_sbs_s.htm) | compile-substitute-if-not | ~200 |
| **Subtotal** | | ~2,650 |

### Summary

| Category | Dead Code Lines |
|----------|----------------|
| I/O Operations | ~1,150 |
| List Operations | ~2,550 |
| Sequence Operations | ~2,650 |
| **Total Estimated** | **~6,350** |

**Target achieved**: 18,351 - 6,350 = 11,999 lines (under 12,000 target)

## Removal Strategy

### Safe Removal Order

1. **Run baseline tests** - Verify all tests pass before changes
2. **Remove I/O functions first** - Smallest impact, simplest to verify
3. **Remove list functions** - Medium complexity
4. **Remove sequence functions** - Largest block
5. **Run tests after each category** - Catch regressions immediately
6. **Run Stage 1 generation** - Verify compilation rate improvement

### Verification Commands

```bash
# Before each removal
sbcl --eval "(asdf:test-system :clysm)"

# After all removals
sbcl --load build/stage1-complete.lisp
wasm-tools validate dist/clysm-stage1.wasm
cat dist/stage1-report.json | jq '.compilation_rate'
```

## Best Practices Applied

### Common Lisp Package Export Best Practices
- Use `:export` in `defpackage` for public symbols
- Re-export from parent packages for convenience
- Document exported symbols in package docstring

### Dead Code Removal Best Practices
- Remove entire function definitions, not partial code
- Update any dispatch tables that reference removed functions
- Search for callers before removal (should be zero for dead code)
- Keep removal commits atomic and well-documented
