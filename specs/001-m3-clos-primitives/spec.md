# Feature Specification: Phase 13D M3 - CLOS Primitives for Wasm

**Feature Branch**: `001-m3-clos-primitives`
**Created**: 2025-12-31
**Status**: Draft
**Input**: Phase 13D M3: CLOS Primitives for Wasm implementation to increase Stage 1 compilation rate from 14.26% to 25%+

## User Scenarios & Testing *(mandatory)*

### User Story 1 - DEFSTRUCT Compilation (Priority: P1)

As a compiler developer, I want DEFSTRUCT forms to compile successfully to Wasm so that structure-based code in the Clysm compiler can be included in Stage 1.

**Why this priority**: DEFSTRUCT accounts for 1953 compilation failures, the largest single blocker. Enabling DEFSTRUCT compilation will have the greatest impact on overall compilation rate.

**Independent Test**: Can be fully tested by compiling `(defstruct point x y)` and verifying the output passes `wasm-tools validate`.

**Acceptance Scenarios**:

1. **Given** a simple DEFSTRUCT form `(defstruct point x y)`, **When** compiled with `clysm:compile-to-wasm`, **Then** valid Wasm bytecode is generated that passes validation
2. **Given** a DEFSTRUCT with `:conc-name` option, **When** compiled, **Then** accessor functions use the specified prefix
3. **Given** a DEFSTRUCT with `:include` option, **When** compiled, **Then** inherited slots are accessible via generated accessors
4. **Given** a DEFSTRUCT with `:read-only` slots, **When** compiled, **Then** no setter functions are generated for read-only slots

---

### User Story 2 - DEFINE-CONDITION Compilation (Priority: P2)

As a compiler developer, I want DEFINE-CONDITION forms to compile successfully to Wasm so that the condition system can be included in Stage 1.

**Why this priority**: DEFINE-CONDITION accounts for 302 compilation failures. While fewer than DEFSTRUCT, conditions are essential for error handling in the self-hosting compiler.

**Independent Test**: Can be fully tested by compiling a simple condition definition and verifying slot access works.

**Acceptance Scenarios**:

1. **Given** a simple DEFINE-CONDITION form, **When** compiled, **Then** valid Wasm bytecode is generated
2. **Given** a condition with parent condition, **When** compiled, **Then** inherited slots are accessible
3. **Given** a condition with `:report` function, **When** compiled, **Then** the report method is callable

---

### User Story 3 - CLOS Instance Operations (Priority: P3)

As a compiler developer, I want CLOS instance operations (`slot-value`, `make-instance`, type predicates) to compile to efficient Wasm primitives so that object-oriented code executes correctly.

**Why this priority**: These primitives are the foundation for both DEFSTRUCT and DEFINE-CONDITION. While lower priority as a standalone story, they enable P1 and P2.

**Independent Test**: Can be fully tested by compiling individual CLOS operations and verifying correct Wasm opcode generation.

**Acceptance Scenarios**:

1. **Given** `(slot-value* instance 'slot-name index)`, **When** compiled, **Then** Wasm `struct.get` opcode is emitted
2. **Given** `(setf (slot-value* instance 'slot-name index) value)`, **When** compiled, **Then** Wasm `struct.set` opcode is emitted
3. **Given** `(make-instance* class-info)`, **When** compiled, **Then** Wasm `struct.new` opcode is emitted
4. **Given** `(standard-instance-p object)`, **When** compiled, **Then** Wasm `ref.test` opcode is emitted

---

### Edge Cases

- What happens when slot index is out of bounds at compile time? (Compile-time error expected)
- How does system handle slot access on nil instances? (Runtime trap expected via Wasm semantics)
- What happens when `make-instance*` is called with invalid class info? (Runtime trap or error condition)
- How does `standard-instance-p` handle non-reference types like i32/f64? (Should return false/nil)

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: Compiler MUST emit `struct.get` opcode when compiling `slot-value*` read operations
- **FR-002**: Compiler MUST emit `struct.set` opcode when compiling `(setf slot-value*)` write operations
- **FR-003**: Compiler MUST emit `struct.new` opcode when compiling `make-instance*` calls
- **FR-004**: Compiler MUST emit `ref.test` opcode when compiling `standard-instance-p` calls
- **FR-005**: Compiler MUST correctly determine slot index from slot name at compile time
- **FR-006**: DEFSTRUCT macro expansion MUST produce compilable CLOS primitive calls
- **FR-007**: DEFINE-CONDITION macro expansion MUST produce compilable CLOS primitive calls
- **FR-008**: Generated Wasm MUST pass `wasm-tools validate` without errors
- **FR-009**: Slot accessors generated by DEFSTRUCT MUST use correct type indices for WasmGC structs

### Key Entities

- **slot-value***: Internal Clysm function for slot access, takes instance, slot-name, and slot-index
- **make-instance***: Internal Clysm function for instance creation, takes class-info and initializers
- **standard-instance-p**: Type predicate for CLOS instances, returns t/nil
- **$instance (type index 6)**: WasmGC struct type for CLOS instances
- **$slot-vector (type index 21)**: WasmGC struct type for slot storage

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Stage 1 compilation rate reaches 25% or higher (up from 14.26%)
- **SC-002**: DEFSTRUCT compilation failure count drops from 1953 to fewer than 100
- **SC-003**: DEFINE-CONDITION compilation failure count drops from 302 to fewer than 50
- **SC-004**: `(defstruct point x y)` compiles successfully and produces valid Wasm
- **SC-005**: Generated `dist/clysm-stage1.wasm` passes `wasm-tools validate` with exit code 0
- **SC-006**: All existing compiler tests continue to pass (no regressions)

## Assumptions

- The existing WasmGC type system (type indices 0-28) is sufficient for CLOS instance representation
- The current macro expansion of DEFSTRUCT to DEFCLASS is correct and produces slot-value* calls
- Slot indices can be determined statically at compile time for known struct types
- The $instance and $slot-vector struct types are already defined in the Wasm module

## Out of Scope

- Generic function dispatch (DEFMETHOD, CALL-NEXT-METHOD)
- Class redefinition and instance update protocols
- Multiple inheritance beyond DEFSTRUCT :include
- MOP (Meta-Object Protocol) extensions
- Runtime class creation
