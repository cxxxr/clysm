# Feature Specification: Primitive Dispatch Table

**Feature Branch**: `002-primitive-dispatch-table`
**Created**: 2026-01-03
**Status**: Draft
**Input**: User description: "Build a compiler code generation optimization for Clysm (a Common Lisp to WasmGC compiler) that migrates the monolithic 363-line case statement in compile-primitive-call to a hash-table driven dispatch system. The system should support registering primitive compilers via register-primitive-compiler API, enable O(1) primitive lookup by symbol or string name, and maintain byte-identical Wasm output. Target: migrate 248 primitives from case branches to table registrations, enabling new primitive addition without modifying core dispatch logic."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Primitive Compilation Lookup (Priority: P1)

A compiler developer compiles Lisp code containing primitive function calls. The compiler looks up the appropriate code generator for each primitive using the new hash-table dispatch system instead of traversing a 363-line case statement. The compiled Wasm output is byte-identical to the previous implementation.

**Why this priority**: This is the core functionality - without correct O(1) dispatch that produces identical output, the entire feature fails. All 248 existing primitives must work correctly through the new system.

**Independent Test**: Can be fully tested by compiling a comprehensive test suite of all 248 primitives and comparing Wasm output byte-for-byte against a baseline generated by the current case-statement implementation.

**Acceptance Scenarios**:

1. **Given** a Lisp expression containing a primitive call (e.g., `(car x)`), **When** the compiler processes the expression, **Then** the primitive dispatch table returns the correct code generator in O(1) time.
2. **Given** the compiler with the new dispatch system, **When** compiling the same source code as with the old case-statement system, **Then** the Wasm binary output is byte-identical.
3. **Given** a primitive name as a symbol (e.g., `CAR`), **When** looking up the primitive compiler, **Then** the correct code generator function is returned.
4. **Given** a primitive name as a string (e.g., `"car"`), **When** looking up the primitive compiler, **Then** the correct code generator function is returned (case-insensitive).

---

### User Story 2 - Register New Primitive (Priority: P2)

A compiler developer adds a new primitive function to Clysm by calling `register-primitive-compiler` with the primitive name and its code generator function, without modifying the core dispatch logic in `compile-primitive-call`.

**Why this priority**: Extensibility is the key benefit of this refactoring. Once dispatch works correctly, enabling clean primitive registration is the next most valuable capability.

**Independent Test**: Can be tested by registering a new test primitive, compiling code that uses it, and verifying correct Wasm output without touching `compile-primitive-call`.

**Acceptance Scenarios**:

1. **Given** a new primitive name and code generator function, **When** calling `register-primitive-compiler`, **Then** the primitive is added to the dispatch table.
2. **Given** a registered new primitive, **When** compiling code that calls it, **Then** the correct Wasm code is generated.
3. **Given** an attempt to register a primitive with a name that already exists, **When** calling `register-primitive-compiler`, **Then** the system signals a warning and overwrites the existing registration (allowing redefinition during development).

---

### User Story 3 - Query Registered Primitives (Priority: P3)

A compiler developer queries the dispatch table to list all registered primitives, check if a specific primitive exists, or retrieve metadata about a primitive's arity or category.

**Why this priority**: Introspection is useful for debugging and tooling but not essential for core compilation functionality.

**Independent Test**: Can be tested by calling query functions and verifying they return accurate information about registered primitives.

**Acceptance Scenarios**:

1. **Given** a populated dispatch table, **When** calling `list-registered-primitives`, **Then** a list of all 248+ primitive names is returned.
2. **Given** a primitive name, **When** calling `primitive-registered-p`, **Then** returns true if registered, false otherwise.
3. **Given** a registered primitive name, **When** calling `get-primitive-info`, **Then** returns metadata including the code generator function and arity information.

---

### Edge Cases

- What happens when looking up a primitive that doesn't exist? The system returns NIL, allowing fallback to general function call compilation.
- What happens when registering a primitive with an empty name or NIL? The system signals an error at registration time.
- What happens when the code generator function is NIL or invalid? The system signals an error at registration time.
- How does the system handle primitives with variant arities (e.g., `+` with 0, 1, 2, or n arguments)? A single variadic handler is registered per primitive name; arity-specific logic is within the handler.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST provide a hash-table based dispatch mechanism for primitive compilation with O(1) average-case lookup time.
- **FR-002**: System MUST support primitive lookup by both symbol and string name (case-insensitive for strings).
- **FR-003**: System MUST provide a `register-primitive-compiler` function that accepts a primitive name and code generator function.
- **FR-004**: System MUST produce byte-identical Wasm output compared to the current case-statement implementation for all 248 existing primitives.
- **FR-005**: System MUST allow registering primitives with arity metadata (minimum args, maximum args, or variadic flag).
- **FR-006**: System MUST provide `primitive-registered-p` predicate to check if a primitive is registered.
- **FR-007**: System MUST provide `list-registered-primitives` function to enumerate all registered primitives.
- **FR-008**: System MUST signal a warning when overwriting an existing primitive registration.
- **FR-009**: System MUST signal an error when registration parameters are invalid (NIL name, NIL function).
- **FR-010**: System MUST return NIL for unknown primitive lookups, enabling fallback behavior.

### Key Entities

- **Primitive Entry**: Represents a registered primitive with its name (symbol), code generator function, minimum arity, maximum arity (or NIL for variadic), and optional category tag.
- **Dispatch Table**: A hash-table mapping primitive symbols to their Primitive Entry records. Supports both symbol and string-based lookups.
- **Code Generator Function**: A function that takes compilation context and arguments, returning Wasm instructions. Must conform to the existing code generator signature used in `compile-primitive-call`.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: All 248 existing primitives compile correctly through the new dispatch system, producing byte-identical Wasm output to the baseline.
- **SC-002**: Primitive lookup completes in O(1) time complexity (constant time regardless of the number of registered primitives).
- **SC-003**: Adding a new primitive requires only a single `register-primitive-compiler` call with no modifications to core dispatch logic.
- **SC-004**: The `compile-primitive-call` function body is reduced from 363 lines to under 30 lines (excluding registration calls).
- **SC-005**: All existing compiler tests pass without modification after the refactoring.
- **SC-006**: New primitives can be registered and used without recompiling core compiler modules.

## Assumptions

- The 363-line case statement mentioned is in `compile-primitive-call` function within the Clysm compiler codebase.
- The 248 primitives represent distinct symbol names; some may share code generators for similar operations.
- String-based lookup uses case-insensitive comparison following Common Lisp symbol naming conventions (uppercase canonical form).
- The hash-table implementation uses the host Lisp's (SBCL) built-in hash-tables with `eq` or `equal` test as appropriate.
- Arity metadata is optional and used for validation/documentation; the code generator function handles actual arity checking.
- The "byte-identical output" requirement applies to the Wasm binary format, not to any intermediate representations.

## Scope Boundaries

### In Scope

- Hash-table dispatch infrastructure
- Registration API (`register-primitive-compiler`, `primitive-registered-p`, etc.)
- Migration of all 248 existing primitives to table registrations
- Backward-compatible output (byte-identical Wasm)
- Arity metadata storage and retrieval

### Out of Scope

- Performance benchmarking beyond O(1) verification
- Runtime dispatch (this is compile-time only)
- Changes to the Wasm instruction generation logic itself
- New primitive implementations (only migration of existing ones)
- Documentation updates beyond inline code comments
